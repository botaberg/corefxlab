<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\PrimitiveParserHelpers.t4" #>
<#

List<TypeToParse> typesToParse = new List<TypeToParse>();

typesToParse.Add(new TypeToParse {
	PrimitiveName = "byte",
	ClassName = "Byte",
	ValueCalculationTypeName = "uint"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "short",
	ClassName = "UInt16",
	ValueCalculationTypeName = "uint"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "uint",
	ClassName = "UInt32",
	ValueCalculationTypeName = "uint"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "ulong",
	ClassName = "UInt64",
	ValueCalculationTypeName = "ulong"
});

List<TryParseOverload> tryParseOverloads = new List<TryParseOverload>();

tryParseOverloads.Add(new TryParseOverload {
	BufferParamsText = "byte* text, int length",
	BytesConsumedParamText = "",
	LengthName = "length"
});

tryParseOverloads.Add(new TryParseOverload {
	BufferParamsText = "byte* text, int length",
	BytesConsumedParamText = ", out int bytesConsumed",
	LengthName = "length"
});

tryParseOverloads.Add(new TryParseOverload {
	BufferParamsText = "ReadOnlySpan<byte> text",
	BytesConsumedParamText = "",
	LengthName = "text.Length"
});

tryParseOverloads.Add(new TryParseOverload {
	BufferParamsText = "ReadOnlySpan<byte> text",
	BytesConsumedParamText = ", out int bytesConsumed",
	LengthName = "text.Length"
});

#>
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantUtf8_unsigned.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
        public static partial class InvariantUtf8
        {
<#
foreach (TypeToParse typeToParse in typesToParse)
{
#>
			#region <#=typeToParse.ClassName#>
<#
	foreach (TryParseOverload tryParseOverload in tryParseOverloads)
	{
#>
            public unsafe static bool TryParse<#=typeToParse.ClassName#>(<#=tryParseOverload.BufferParamsText#>, out <#=typeToParse.PrimitiveName#> value<#=tryParseOverload.BytesConsumedParamText#>)
            {
                if (<#=tryParseOverload.LengthName#> < 1)
                {
<#
		PrintSetOutParamsAndReturnFalseText(typeToParse, tryParseOverload, 5);
#>
                }

                // Parse the first digit separately. If invalid here, we need to return false.
                <#=typeToParse.ValueCalculationTypeName#> firstDigit = text[0] - 48u; // '0'
                if (firstDigit > 9)
                {
<#
		PrintSetOutParamsAndReturnFalseText(typeToParse, tryParseOverload, 5);
#>
                }
                <#=typeToParse.ValueCalculationTypeName#> parsedValue = firstDigit;

                if (<#=tryParseOverload.LengthName#> < <#=typeToParse.ClassName#>OverflowLength)
                {
                    // Length is less than <#=typeToParse.ClassName#>OverflowLength; overflow is not possible
                    for (int index = 1; index < <#=tryParseOverload.LengthName#>; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48u; // '0'
                        if (nextDigit > 9)
                        {
<#
		PrintSetOutParamsAndReturnTrueText(typeToParse, tryParseOverload, false, 7);
#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                }
                else
                {
                    // Length is greater than <#=typeToParse.ClassName#>OverflowLength; overflow is only possible after <#=typeToParse.ClassName#>OverflowLength
                    // digits. There may be no overflow after <#=typeToParse.ClassName#>OverflowLength if there are leading zeroes.
                    for (int index = 1; index < <#=typeToParse.ClassName#>OverflowLength - 1; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48u; // '0'
                        if (nextDigit > 9)
                        {
<#
		PrintSetOutParamsAndReturnTrueText(typeToParse, tryParseOverload, false, 7);
#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                    for (int index = <#=typeToParse.ClassName#>OverflowLength - 1; index < <#=tryParseOverload.LengthName#>; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48u; // '0'
                        if (nextDigit > 9)
                        {
<#
		PrintSetOutParamsAndReturnTrueText(typeToParse, tryParseOverload, false, 7);
#>
                        }
                        // If parsedValue > (<#=typeToParse.PrimitiveName#>.MaxValue / 10), any more appended digits will cause overflow.
                        // if parsedValue == (<#=typeToParse.PrimitiveName#>.MaxValue / 10), any nextDigit greater than 5 implies overflow.
                        if (parsedValue > <#=typeToParse.PrimitiveName#>.MaxValue / 10 || (parsedValue == <#=typeToParse.PrimitiveName#>.MaxValue / 10 && nextDigit > 5))
                        {
<#
		PrintSetOutParamsAndReturnFalseText(typeToParse, tryParseOverload, 7);
#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                }

<#
		PrintSetOutParamsAndReturnTrueText(typeToParse, tryParseOverload, true, 4);
#>
            }

<#
	}
#>
			#endregion

<#
}
#>
        }
    }
}