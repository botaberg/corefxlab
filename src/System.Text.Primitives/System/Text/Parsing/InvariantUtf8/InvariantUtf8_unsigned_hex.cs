// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantUtf8_unsigned.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
        public static partial class InvariantUtf8
        {
			public static partial class Hex
			{
				#region Byte
				public unsafe static bool TryParseByte(byte* text, int length, out byte value)
				{
					if (length < 1)
					{
                        value = default(byte);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(byte);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (length < ByteOverflowLengthHex)
					{
						// Length is less than ByteOverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than ByteOverflowLengthHex; overflow is only possible after ByteOverflowLengthHex
						// digits. There may be no overflow after ByteOverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < ByteOverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = ByteOverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (byte)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than byte.MaxValue / 0x10, there will be overflow
							if (parsedValue > byte.MaxValue / 0x10)
							{
                                value = default(byte);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = (byte)parsedValue;
                    return true;
				}

				public unsafe static bool TryParseByte(byte* text, int length, out byte value, out int bytesConsumed)
				{
					if (length < 1)
					{
                        bytesConsumed = 0;
                        value = default(byte);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(byte);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (length < ByteOverflowLengthHex)
					{
						// Length is less than ByteOverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than ByteOverflowLengthHex; overflow is only possible after ByteOverflowLengthHex
						// digits. There may be no overflow after ByteOverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < ByteOverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = ByteOverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (byte)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than byte.MaxValue / 0x10, there will be overflow
							if (parsedValue > byte.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(byte);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = length;
                    value = (byte)parsedValue;
                    return true;
				}

				public unsafe static bool TryParseByte(ReadOnlySpan<byte> text, out byte value)
				{
					if (text.Length < 1)
					{
                        value = default(byte);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(byte);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (text.Length < ByteOverflowLengthHex)
					{
						// Length is less than ByteOverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than ByteOverflowLengthHex; overflow is only possible after ByteOverflowLengthHex
						// digits. There may be no overflow after ByteOverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < ByteOverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = ByteOverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (byte)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than byte.MaxValue / 0x10, there will be overflow
							if (parsedValue > byte.MaxValue / 0x10)
							{
                                value = default(byte);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = (byte)parsedValue;
                    return true;
				}

				public unsafe static bool TryParseByte(ReadOnlySpan<byte> text, out byte value, out int bytesConsumed)
				{
					if (text.Length < 1)
					{
                        bytesConsumed = 0;
                        value = default(byte);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(byte);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (text.Length < ByteOverflowLengthHex)
					{
						// Length is less than ByteOverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than ByteOverflowLengthHex; overflow is only possible after ByteOverflowLengthHex
						// digits. There may be no overflow after ByteOverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < ByteOverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (byte)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = ByteOverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (byte)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than byte.MaxValue / 0x10, there will be overflow
							if (parsedValue > byte.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(byte);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = text.Length;
                    value = (byte)parsedValue;
                    return true;
				}

				#endregion

				#region UInt16
				public unsafe static bool TryParseUInt16(byte* text, int length, out short value)
				{
					if (length < 1)
					{
                        value = default(short);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(short);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (length < UInt16OverflowLengthHex)
					{
						// Length is less than UInt16OverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt16OverflowLengthHex; overflow is only possible after UInt16OverflowLengthHex
						// digits. There may be no overflow after UInt16OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt16OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt16OverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (short)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than short.MaxValue / 0x10, there will be overflow
							if (parsedValue > short.MaxValue / 0x10)
							{
                                value = default(short);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = (short)parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt16(byte* text, int length, out short value, out int bytesConsumed)
				{
					if (length < 1)
					{
                        bytesConsumed = 0;
                        value = default(short);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(short);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (length < UInt16OverflowLengthHex)
					{
						// Length is less than UInt16OverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt16OverflowLengthHex; overflow is only possible after UInt16OverflowLengthHex
						// digits. There may be no overflow after UInt16OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt16OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt16OverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (short)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than short.MaxValue / 0x10, there will be overflow
							if (parsedValue > short.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(short);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = length;
                    value = (short)parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt16(ReadOnlySpan<byte> text, out short value)
				{
					if (text.Length < 1)
					{
                        value = default(short);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(short);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (text.Length < UInt16OverflowLengthHex)
					{
						// Length is less than UInt16OverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt16OverflowLengthHex; overflow is only possible after UInt16OverflowLengthHex
						// digits. There may be no overflow after UInt16OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt16OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt16OverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = (short)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than short.MaxValue / 0x10, there will be overflow
							if (parsedValue > short.MaxValue / 0x10)
							{
                                value = default(short);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = (short)parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt16(ReadOnlySpan<byte> text, out short value, out int bytesConsumed)
				{
					if (text.Length < 1)
					{
                        bytesConsumed = 0;
                        value = default(short);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(short);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (text.Length < UInt16OverflowLengthHex)
					{
						// Length is less than UInt16OverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt16OverflowLengthHex; overflow is only possible after UInt16OverflowLengthHex
						// digits. There may be no overflow after UInt16OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt16OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (short)parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt16OverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = (short)parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than short.MaxValue / 0x10, there will be overflow
							if (parsedValue > short.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(short);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = text.Length;
                    value = (short)parsedValue;
                    return true;
				}

				#endregion

				#region UInt32
				public unsafe static bool TryParseUInt32(byte* text, int length, out uint value)
				{
					if (length < 1)
					{
                        value = default(uint);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(uint);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (length < UInt32OverflowLengthHex)
					{
						// Length is less than UInt32OverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt32OverflowLengthHex; overflow is only possible after UInt32OverflowLengthHex
						// digits. There may be no overflow after UInt32OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt32OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt32OverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than uint.MaxValue / 0x10, there will be overflow
							if (parsedValue > uint.MaxValue / 0x10)
							{
                                value = default(uint);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt32(byte* text, int length, out uint value, out int bytesConsumed)
				{
					if (length < 1)
					{
                        bytesConsumed = 0;
                        value = default(uint);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(uint);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (length < UInt32OverflowLengthHex)
					{
						// Length is less than UInt32OverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt32OverflowLengthHex; overflow is only possible after UInt32OverflowLengthHex
						// digits. There may be no overflow after UInt32OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt32OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt32OverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than uint.MaxValue / 0x10, there will be overflow
							if (parsedValue > uint.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(uint);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = length;
                    value = parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt32(ReadOnlySpan<byte> text, out uint value)
				{
					if (text.Length < 1)
					{
                        value = default(uint);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(uint);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (text.Length < UInt32OverflowLengthHex)
					{
						// Length is less than UInt32OverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt32OverflowLengthHex; overflow is only possible after UInt32OverflowLengthHex
						// digits. There may be no overflow after UInt32OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt32OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt32OverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than uint.MaxValue / 0x10, there will be overflow
							if (parsedValue > uint.MaxValue / 0x10)
							{
                                value = default(uint);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt32(ReadOnlySpan<byte> text, out uint value, out int bytesConsumed)
				{
					if (text.Length < 1)
					{
                        bytesConsumed = 0;
                        value = default(uint);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(uint);
                        return false;
					}
					uint parsedValue = firstDigit;

					if (text.Length < UInt32OverflowLengthHex)
					{
						// Length is less than UInt32OverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt32OverflowLengthHex; overflow is only possible after UInt32OverflowLengthHex
						// digits. There may be no overflow after UInt32OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt32OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt32OverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than uint.MaxValue / 0x10, there will be overflow
							if (parsedValue > uint.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(uint);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = text.Length;
                    value = parsedValue;
                    return true;
				}

				#endregion

				#region UInt64
				public unsafe static bool TryParseUInt64(byte* text, int length, out ulong value)
				{
					if (length < 1)
					{
                        value = default(ulong);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(ulong);
                        return false;
					}
					ulong parsedValue = firstDigit;

					if (length < UInt64OverflowLengthHex)
					{
						// Length is less than UInt64OverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt64OverflowLengthHex; overflow is only possible after UInt64OverflowLengthHex
						// digits. There may be no overflow after UInt64OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt64OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt64OverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than ulong.MaxValue / 0x10, there will be overflow
							if (parsedValue > ulong.MaxValue / 0x10)
							{
                                value = default(ulong);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt64(byte* text, int length, out ulong value, out int bytesConsumed)
				{
					if (length < 1)
					{
                        bytesConsumed = 0;
                        value = default(ulong);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(ulong);
                        return false;
					}
					ulong parsedValue = firstDigit;

					if (length < UInt64OverflowLengthHex)
					{
						// Length is less than UInt64OverflowLengthHex; overflow is not possible
						for (int index = 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt64OverflowLengthHex; overflow is only possible after UInt64OverflowLengthHex
						// digits. There may be no overflow after UInt64OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt64OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt64OverflowLengthHex - 1; index < length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than ulong.MaxValue / 0x10, there will be overflow
							if (parsedValue > ulong.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(ulong);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = length;
                    value = parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt64(ReadOnlySpan<byte> text, out ulong value)
				{
					if (text.Length < 1)
					{
                        value = default(ulong);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        value = default(ulong);
                        return false;
					}
					ulong parsedValue = firstDigit;

					if (text.Length < UInt64OverflowLengthHex)
					{
						// Length is less than UInt64OverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt64OverflowLengthHex; overflow is only possible after UInt64OverflowLengthHex
						// digits. There may be no overflow after UInt64OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt64OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt64OverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than ulong.MaxValue / 0x10, there will be overflow
							if (parsedValue > ulong.MaxValue / 0x10)
							{
                                value = default(ulong);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    value = parsedValue;
                    return true;
				}

				public unsafe static bool TryParseUInt64(ReadOnlySpan<byte> text, out ulong value, out int bytesConsumed)
				{
					if (text.Length < 1)
					{
                        bytesConsumed = 0;
                        value = default(ulong);
                        return false;
					}

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
					byte firstByte = text[0];
                    byte firstDigit = hexLookup[firstByte];
                    if (firstDigit == 0xFF)
					{
                        bytesConsumed = 0;
                        value = default(ulong);
                        return false;
					}
					ulong parsedValue = firstDigit;

					if (text.Length < UInt64OverflowLengthHex)
					{
						// Length is less than UInt64OverflowLengthHex; overflow is not possible
						for (int index = 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}
					else
					{
						// Length is greater than UInt64OverflowLengthHex; overflow is only possible after UInt64OverflowLengthHex
						// digits. There may be no overflow after UInt64OverflowLengthHex if there are leading zeroes.
						for (int index = 1; index < UInt64OverflowLengthHex - 1; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
						for (int index = UInt64OverflowLengthHex - 1; index < text.Length; index++)
						{
							byte nextByte = text[index];
                            byte nextDigit = hexLookup[nextByte];
                            if (nextDigit == 0xFF)
							{
                                bytesConsumed = index;
                                value = parsedValue;
                                return true;
							}
							// If we try to append a digit to anything larger than ulong.MaxValue / 0x10, there will be overflow
							if (parsedValue > ulong.MaxValue / 0x10)
							{
                                bytesConsumed = 0;
                                value = default(ulong);
                                return false;
							}
							parsedValue = parsedValue * 0x10 + nextDigit;
						}
					}

                    bytesConsumed = text.Length;
                    value = parsedValue;
                    return true;
				}

				#endregion

			}
        }
    }
}