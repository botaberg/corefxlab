<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="PrimitiveParserHelpers.t4" #>
<#

List<TypeToParse> typesToParse = new List<TypeToParse>();

typesToParse.Add(new TypeToParse {
	PrimitiveName = "byte",
	ClassName = "Byte",
	ValueCalculationTypeName = "uint"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "ushort",
	ClassName = "UInt16",
	ValueCalculationTypeName = "uint"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "uint",
	ClassName = "UInt32",
	ValueCalculationTypeName = "uint"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "ulong",
	ClassName = "UInt64",
	ValueCalculationTypeName = "ulong"
});

List<TryParseSignature> TryParseSignatures = new List<TryParseSignature>();

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ArrayPointer,
	ConsumedParameterExists = false
});

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ArrayPointer,
	ConsumedParameterExists = true
});

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ReadOnlySpan,
	ConsumedParameterExists = false
});

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ReadOnlySpan,
	ConsumedParameterExists = true
});

List<Encoding> utfEncodings = new List<Encoding> { Encoding.Utf8, Encoding.Utf16 };

#>
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantUnsignedHex.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
<#
foreach (Encoding utfEncoding in utfEncodings)
{
#>
        public static partial class Invariant<#=utfEncoding#>
        {
			public static partial class Hex
			{
<#
	foreach (TypeToParse typeToParse in typesToParse)
	{
#>
				#region <#=typeToParse.ClassName#>
<#
		foreach (TryParseSignature tryParseSignature in TryParseSignatures)
		{
			TryParseOverload tryParseOverload = new TryParseOverload(typeToParse, tryParseSignature, utfEncoding, false);
#>
				public unsafe static bool TryParse<#=typeToParse.ClassName#>(<#=tryParseOverload.BufferParamsText#>, out <#=typeToParse.PrimitiveName#> value<#=tryParseOverload.ConsumedParamText#>)
				{
					if (<#=tryParseOverload.LengthName#> < 1)
					{
<#=tryParseOverload.SetOutParamsAndReturnFalse(6)#>
					}
					<#=tryParseOverload.CharacterPrimitive#> nextCharacter;
					byte nextDigit;

					// Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

					// Parse the first digit separately. If invalid here, we need to return false.
<#=tryParseOverload.ParseOneHexCharacter("0", 5)#>
					{
<#=tryParseOverload.SetOutParamsAndReturnFalse(6)#>
					}
					<#=typeToParse.ValueCalculationTypeName#> parsedValue = nextDigit;

					if (<#=tryParseOverload.LengthName#> <= <#=tryParseOverload.OverflowLengthName#>Hex)
					{
						// Length is less than or equal to <#=tryParseOverload.OverflowLengthName#>Hex; overflow is not possible
						for (int index = 1; index < <#=tryParseOverload.LengthName#>; index++)
						{
<#=tryParseOverload.ParseOneHexCharacter("index", 7)#>
							{
<#=tryParseOverload.SetOutParamsAndReturnTrue(false, 8)#>
							}
							parsedValue = (parsedValue << 4) + nextDigit;
						}
					}
					else
					{
						// Length is greater than <#=tryParseOverload.OverflowLengthName#>Hex; overflow is only possible after <#=tryParseOverload.OverflowLengthName#>Hex
						// digits. There may be no overflow after <#=tryParseOverload.OverflowLengthName#>Hex if there are leading zeroes.
						for (int index = 1; index < <#=tryParseOverload.OverflowLengthName#>Hex; index++)
						{
<#=tryParseOverload.ParseOneHexCharacter("index", 7)#>
							{
<#=tryParseOverload.SetOutParamsAndReturnTrue(false, 8)#>
							}
							parsedValue = (parsedValue << 4) + nextDigit;
						}
						for (int index = <#=tryParseOverload.OverflowLengthName#>Hex; index < <#=tryParseOverload.LengthName#>; index++)
						{
<#=tryParseOverload.ParseOneHexCharacter("index", 7)#>
							{
<#=tryParseOverload.SetOutParamsAndReturnTrue(false, 8)#>
							}
							// If we try to append a digit to anything larger than <#=typeToParse.PrimitiveName#>.MaxValue / 0x10, there will be overflow
							if (parsedValue > <#=typeToParse.PrimitiveName#>.MaxValue / 0x10)
							{
<#=tryParseOverload.SetOutParamsAndReturnFalse(8)#>
							}
							parsedValue = (parsedValue << 4) + nextDigit;
						}
					}

<#=tryParseOverload.SetOutParamsAndReturnTrue(true, 5)#>
				}

<#
		}
#>
				#endregion

<#
	}
#>
			}
        }
<#
}
#>
    }
}