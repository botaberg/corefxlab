<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="PrimitiveParserHelpers.t4" #>
<#

List<UtfEncoding> utfEncodings = new List<UtfEncoding> { UtfEncoding.Utf8, UtfEncoding.Utf16 };
List<bool> consumedParamTypes = new List<bool> { false, true };
List<BufferType> bufferTypes = new List<BufferType> { BufferType.ArrayPointer, BufferType.ReadOnlySpan };

#>
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantUri.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
<#
foreach (UtfEncoding utfEncoding in utfEncodings)
{
#>
        public static partial class Invariant<#=utfEncoding#>
        {
<#
    foreach (BufferType bufferType in bufferTypes)
    {
        foreach (bool consumedParamType in consumedParamTypes)
        {
            TryParseSignature tryParseSignature = new TryParseSignature(bufferType, consumedParamType, utfEncoding);
#>
            public <#=tryParseSignature.UnsafeModifier#>static bool TryParseUri(<#=tryParseSignature.BufferParamsText#>, out Uri value<#=tryParseSignature.ConsumedParamText#>)
            {
                if (<#=tryParseSignature.LengthName#> < 1)
                {
                    value = default(Uri);
                    <#=SetConsumedIfApplicable(consumedParamType, tryParseSignature.CharacterPrimitive, "0")#>
                    return false;
                }

                StringBuilder sb = new StringBuilder(<#=tryParseSignature.LengthName#>);
                <#=tryParseSignature.CharacterPrimitive#> nextCharacter = text[0];
                if (nextCharacter == '#' || nextCharacter == '&' || nextCharacter == '=' || nextCharacter == '?' || nextCharacter == '_' || nextCharacter == '\\' || nextCharacter == ':' ||
                    nextCharacter >= '-' && nextCharacter <= '9' || nextCharacter >= 'A' && nextCharacter <= 'Z' || nextCharacter >= 'a' && nextCharacter <= 'z')
                {
                    sb.Append((char)nextCharacter);
                }
                else
                {
                    value = default(Uri);
                    <#=SetConsumedIfApplicable(consumedParamType, tryParseSignature.CharacterPrimitive, "0")#>
                    return false;
                }

                for (int i = 1; i < <#=tryParseSignature.LengthName#>; i++)
                {
                    nextCharacter = text[i];
                    if (nextCharacter == '#' || nextCharacter == '&' || nextCharacter == '=' || nextCharacter == '?' || nextCharacter == '_' || nextCharacter == '\\' || nextCharacter == ':' ||
                    nextCharacter >= '-' && nextCharacter <= '9' || nextCharacter >= 'A' && nextCharacter <= 'Z' || nextCharacter >= 'a' && nextCharacter <= 'z')
                    {
                        sb.Append((char)nextCharacter);
                    }
                    else
                    {
                        if (Uri.TryCreate(sb.ToString(), UriKind.Absolute, out value))
                        {
                            <#=SetConsumedIfApplicable(consumedParamType, tryParseSignature.CharacterPrimitive, "i")#>
                            return true;
                        }
                        else
                        {
                            value = default(Uri);
                            <#=SetConsumedIfApplicable(consumedParamType, tryParseSignature.CharacterPrimitive, "0")#>
                            return false;
                        }
                    }
                }

                if (Uri.TryCreate(sb.ToString(), UriKind.Absolute, out value))
                {
                    <#=SetConsumedIfApplicable(consumedParamType, tryParseSignature.CharacterPrimitive, tryParseSignature.LengthName)#>
                    return true;
                }
                else
                {
                    value = default(Uri);
                    <#=SetConsumedIfApplicable(consumedParamType, tryParseSignature.CharacterPrimitive, "0")#>
                    return false;
                }
            }
<#
        }
    }
#>
        }
<#
}
#>
    }
}
<#+
string SetConsumedIfApplicable(bool applicable, string characterPrimitive, string value)
{
    if (applicable)
    {
        return string.Format("{0}sConsumed = {1};", characterPrimitive, value);
    }
    return "// No need to set consumed";
}
#>