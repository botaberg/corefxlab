<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="PrimitiveParserHelpers.t4" #>
<#

List<TypeToParse> typesToParse = new List<TypeToParse>();

typesToParse.Add(new TypeToParse {
	PrimitiveName = "sbyte",
	ClassName = "SByte",
	ValueCalculationTypeName = "int"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "short",
	ClassName = "Int16",
	ValueCalculationTypeName = "int"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "int",
	ClassName = "Int32",
	ValueCalculationTypeName = "int"
});

typesToParse.Add(new TypeToParse {
	PrimitiveName = "long",
	ClassName = "Int64",
	ValueCalculationTypeName = "long"
});

List<TryParseSignature> TryParseSignatures = new List<TryParseSignature>();

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ArrayPointer,
	ConsumedParameterExists = false
});

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ArrayPointer,
	ConsumedParameterExists = true
});

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ReadOnlySpan,
	ConsumedParameterExists = false
});

TryParseSignatures.Add(new TryParseSignature {
	BufferType = BufferType.ReadOnlySpan,
	ConsumedParameterExists = true
});

List<Encoding> utfEncodings = new List<Encoding> { Encoding.Utf8, Encoding.Utf16 };

#>
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantSigned.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
<#
foreach (Encoding utfEncoding in utfEncodings)
{
#>
        public static partial class Invariant<#=utfEncoding#>
        {
<#
	foreach (TypeToParse typeToParse in typesToParse)
	{
#>
			#region <#=typeToParse.ClassName#>
<#
		foreach (TryParseSignature tryParseSignature in TryParseSignatures)
		{
			TryParseOverload tryParseOverload = new TryParseOverload(typeToParse, tryParseSignature, utfEncoding, true);
#>
            public unsafe static bool TryParse<#=typeToParse.ClassName#>(<#=tryParseOverload.BufferParamsText#>, out <#=typeToParse.PrimitiveName#> value<#=tryParseOverload.ConsumedParamText#>)
            {
                if (<#=tryParseOverload.LengthName#> < 1)
                {
<#=tryParseOverload.SetOutParamsAndReturnFalse(5)#>
                }

				int indexOfFirstDigit = 0;
				int sign = 1;
				if (text[0] == '-')
				{
					indexOfFirstDigit = 1;
					sign = -1;
				}
				else if (text[0] == '+')
				{
					indexOfFirstDigit = 1;
				}

				int overflowLength = <#=tryParseOverload.OverflowLengthName#> + indexOfFirstDigit;

                // Parse the first digit separately. If invalid here, we need to return false.
                <#=typeToParse.ValueCalculationTypeName#> firstDigit = text[indexOfFirstDigit] - 48; // '0'
                if (firstDigit < 0 || firstDigit > 9)
                {
<#=tryParseOverload.SetOutParamsAndReturnFalse(5)#>
                }
                <#=typeToParse.ValueCalculationTypeName#> parsedValue = firstDigit;

                if (<#=tryParseOverload.LengthName#> < overflowLength)
                {
                    // Length is less than <#=tryParseOverload.OverflowLengthName#>; overflow is not possible
                    for (int index = indexOfFirstDigit + 1; index < <#=tryParseOverload.LengthName#>; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48; // '0'
                        if (nextDigit < 0 || nextDigit > 9)
                        {
<#=tryParseOverload.SetOutParamsAndReturnTrue(false, 7)#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                }
                else
                {
                    // Length is greater than <#=tryParseOverload.OverflowLengthName#>; overflow is only possible after <#=tryParseOverload.OverflowLengthName#>
                    // digits. There may be no overflow after <#=tryParseOverload.OverflowLengthName#> if there are leading zeroes.
                    for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48; // '0'
                        if (nextDigit < 0 || nextDigit > 9)
                        {
<#=tryParseOverload.SetOutParamsAndReturnTrue(false, 7)#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                    for (int index = overflowLength - 1; index < <#=tryParseOverload.LengthName#>; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48; // '0'
                        if (nextDigit < 0 || nextDigit > 9)
                        {
<#=tryParseOverload.SetOutParamsAndReturnTrue(false, 7)#>
                        }
                        // If parsedValue > (<#=typeToParse.PrimitiveName#>.MaxValue / 10), any more appended digits will cause overflow.
                        // if parsedValue == (<#=typeToParse.PrimitiveName#>.MaxValue / 10), any nextDigit greater than 7 or 8 (depending on sign) implies overflow.
						bool positive = sign > 0;
						bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);
                        if (parsedValue > <#=typeToParse.PrimitiveName#>.MaxValue / 10 || parsedValue == <#=typeToParse.PrimitiveName#>.MaxValue / 10 && nextDigitTooLarge)
                        {
<#=tryParseOverload.SetOutParamsAndReturnFalse(7)#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                }

<#=tryParseOverload.SetOutParamsAndReturnTrue(true, 4)#>
            }

<#
		}
#>
			#endregion

<#
	}
#>
        }
<#
}
#>
    }
}