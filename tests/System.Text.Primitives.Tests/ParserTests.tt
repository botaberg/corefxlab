<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#
	string[] utfEncodings = new string[] {"8", "16"};

	Type[] unsignedTypes = new Type[] { typeof(byte), typeof(ushort), typeof(uint), typeof(ulong) };
	string[] unsignedPrimitives = new string[] { "byte", "ushort", "uint", "ulong" };
    string[] unsignedClasses = new string[] { "Byte", "UInt16", "UInt32", "UInt64" };

	Type[] signedTypes = new Type[] { typeof(sbyte), typeof(short), typeof(int), typeof(long) };
	string[] signedPrimitives = new string[] { "sbyte", "short", "int", "long" };
    string[] signedClasses = new string[] { "SByte", "Int16", "Int32", "Int64" };
#>
// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in ParserTests.tt.

using Xunit;

namespace System.Text.Primitives.Tests
{
	public partial class PrimitiveParserTests
    {
        private byte[] UtfEncode(string s, bool utf16)
        {
            if (utf16)
                return Encoding.Unicode.GetBytes(s);
            else
                return Encoding.UTF8.GetBytes(s);
        }

<#
		for (int i = 0; i < unsignedTypes.Length; i++)
		{
			string capitalizedPrimitive = (char)(unsignedPrimitives[i][0] - 32) + unsignedPrimitives[i].Remove(0,1);

			var minValue = unsignedTypes[i].GetField("MinValue").GetValue(null);
			var maxValue = unsignedTypes[i].GetField("MaxValue").GetValue(null);
			int minValueLength = minValue.ToString().Length;
			int maxValueLength = maxValue.ToString().Length;

			string maxString = maxValue.ToString();

			char overflowChar = (char)(maxString[maxString.Length - 1] + 1);
			string overflowValue = maxString.Remove(maxString.Length - 1) + overflowChar;

			string midValue = maxString.Remove(0,1);
		
			StringBuilder randValueSB = new StringBuilder();
			Random r = new Random(55); // a seed is used so that the same "random" values are always generated
									   // good for test consistency
			foreach (char c in midValue)
			{
				if (c > '5')
				{
					randValueSB.Append((char)(c - r.Next(0,5)));
				}
				else
				{
					randValueSB.Append((char)(c + r.Next(0,4)));
				}
			}
			string randValue = randValueSB.ToString();

#>
		#region <#= unsignedPrimitives[i] #>

<#
			foreach (var utfEncoding in utfEncodings)
			{
#>
		[Theory]
        [InlineData("<#= midValue #>", true, <#= midValue #>)]
        [InlineData("<#= randValue #>abhced", true, <#= randValue #>)]
        [InlineData("<#= minValue #>", true, <#= minValue #>)] // min value
        [InlineData("<#= maxValue #>", true, <#= maxValue #>)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0)] // overflow test
        public unsafe void ParseUtf<#= utfEncoding #>SpanTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, <#= unsignedPrimitives[i] #> expectedValue)
        {
            <#= unsignedPrimitives[i] #> parsedValue;
			var span = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=unsignedClasses[i]#>(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("<#= midValue #>", true, <#= midValue #>, <#= midValue.Length #>)]
        [InlineData("<#= randValue #>abhced", true, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("<#= minValue #>", true, <#= minValue #>, <#= minValueLength #>)] // min value
        [InlineData("<#= maxValue #>", true, <#= maxValue #>, <#= maxValueLength #>)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0)] // overflow test
        public unsafe void ParseUtf<#= utfEncoding #>SpanTo<#= capitalizedPrimitive #>Consumed(string text, bool expectSuccess, <#= unsignedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= unsignedPrimitives[i] #> parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=unsignedClasses[i]#>(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("<#= midValue #>", true, <#= midValue #>)]
        [InlineData("<#= randValue #>abhced", true, <#= randValue #>)]
        [InlineData("<#= minValue #>", true, <#= minValue #>)] // min value
        [InlineData("<#= maxValue #>", true, <#= maxValue #>)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0)] // overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteStarTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, <#= unsignedPrimitives[i] #> expectedValue)
        {
            <#= unsignedPrimitives[i] #> parsedValue;

            byte[] textBytes = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=unsignedClasses[i]#>(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("<#= midValue #>", true, <#= midValue #>, <#= midValue.Length #>)]
        [InlineData("<#= randValue #>abhced", true, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("<#= minValue #>", true, <#= minValue #>, <#= minValueLength #>)] // min value
        [InlineData("<#= maxValue #>", true, <#= maxValue #>, <#= maxValueLength #>)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0)] // overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteStarTo<#= capitalizedPrimitive #>Consumed(string text, bool expectSuccess, <#= unsignedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= unsignedPrimitives[i] #> parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=unsignedClasses[i]#>(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

<#
			}
#>
		#endregion

<#
		}
#>
<#
		for (int i = 0; i < signedTypes.Length; i++)
		{
			string capitalizedPrimitive = (char)(signedPrimitives[i][0] - 32) + signedPrimitives[i].Remove(0,1);

			var minValue = signedTypes[i].GetField("MinValue").GetValue(null);
			var maxValue = signedTypes[i].GetField("MaxValue").GetValue(null);
			int minValueLength = minValue.ToString().Length;
			int maxValueLength = maxValue.ToString().Length;

			string maxString = maxValue.ToString();
			string minString = minValue.ToString();

			char overflowChar = (char)(maxString[maxString.Length - 1] + 1);
			string overflowValue = maxString.Remove(maxString.Length - 1) + overflowChar;
			
			char underflowChar = (char)(minString[minString.Length - 1] + 1);
			string underflowValue = minString.Remove(minString.Length - 1) + underflowChar;

			string midValue = maxString.Remove(0,1);
			string midMinValue = minString.Remove(1,1);
		
			StringBuilder randValueSB = new StringBuilder();
			Random r = new Random(123); // a seed is used so that the same "random" values are always generated
									   // good for test consistency
			foreach (char c in midValue)
			{
				if (c > '5')
				{
					randValueSB.Append((char)(c - r.Next(0,5)));
				}
				else
				{
					randValueSB.Append((char)(c + r.Next(0,4)));
				}
			}
			string randValue = randValueSB.ToString();

#>
		#region <#= signedPrimitives[i] #>

<#
			foreach (var utfEncoding in utfEncodings)
			{
#>
		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("<#= randValue #>abcdefg", true, <#= randValue #>)]
        [InlineData("<#= maxValue #>", true, <#= maxValue #>)] // max
        [InlineData("<#= minValue #>", true, <#= minValue #>)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0,)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0,)] // negative overflow test
        public void ParseUtf<#= utfEncoding #>SpanTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, <#= signedPrimitives[i] #> expectedValue)
        {
            <#= signedPrimitives[i] #> parsedValue;
			var span = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=signedClasses[i]#>(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("<#= randValue #>abcdefg", true, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("<#= maxValue #>", true, <#= maxValue #>, <#= maxValueLength #>)] // max
        [InlineData("<#= minValue #>", true, <#= minValue #>, <#= minValueLength #>)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0, 0)] // negative overflow test
        public void ParseUtf<#= utfEncoding #>SpanTo<#= capitalizedPrimitive #>Consumed(string text, bool expectSuccess, <#= signedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= signedPrimitives[i] #> parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=signedClasses[i]#>(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("<#= randValue #>abcdefg", true, <#= randValue #>)]
        [InlineData("<#= maxValue #>", true, <#= maxValue #>)] // max
        [InlineData("<#= minValue #>", true, <#= minValue #>)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0)] // negative overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteStarTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, <#= signedPrimitives[i] #> expectedValue)
        {
            <#= signedPrimitives[i] #> parsedValue;

            byte[] textBytes = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=signedClasses[i]#>(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("<#= randValue #>abcdefg", true, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("<#= maxValue #>", true, <#= maxValue #>, <#= maxValueLength #>)] // max
        [InlineData("<#= minValue #>", true, <#= minValue #>, <#= minValueLength #>)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteStarTo<#= capitalizedPrimitive #>Consumed(string text, bool expectSuccess, <#= signedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= signedPrimitives[i] #> parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf<#= utfEncoding #>.TryParse<#=signedClasses[i]#>(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
<#
			}
#>
		#endregion

<#
		}
#>
	}
}