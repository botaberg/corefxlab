// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in ParserTests.tt.

using Xunit;

namespace System.Text.Primitives.Tests
{
	public partial class PrimitiveParserTests
    {
        private byte[] UtfEncode(string s, bool utf16)
        {
            if (utf16)
                return Encoding.Unicode.GetBytes(s);
            else
                return Encoding.UTF8.GetBytes(s);
        }

		#region byte

		[Theory]
        [InlineData("55", true, 55)]
        [InlineData("68abhced", true, 68)]
        [InlineData("0", true, 0)] // min value
        [InlineData("255", true, 255)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0)] // overflow test
        public unsafe void ParseUtf8SpanToByte(string text, bool expectSuccess, byte expectedValue)
        {
            byte parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseByte(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("55", true, 55, 2)]
        [InlineData("68abhced", true, 68, 2)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("255", true, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToByteConsumed(string text, bool expectSuccess, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseByte(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("55", true, 55)]
        [InlineData("68abhced", true, 68)]
        [InlineData("0", true, 0)] // min value
        [InlineData("255", true, 255)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToByte(string text, bool expectSuccess, byte expectedValue)
        {
            byte parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseByte(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("55", true, 55, 2)]
        [InlineData("68abhced", true, 68, 2)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("255", true, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToByteConsumed(string text, bool expectSuccess, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseByte(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		[Theory]
        [InlineData("55", true, 55)]
        [InlineData("68abhced", true, 68)]
        [InlineData("0", true, 0)] // min value
        [InlineData("255", true, 255)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0)] // overflow test
        public unsafe void ParseUtf16SpanToByte(string text, bool expectSuccess, byte expectedValue)
        {
            byte parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseByte(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("55", true, 55, 2)]
        [InlineData("68abhced", true, 68, 2)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("255", true, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToByteConsumed(string text, bool expectSuccess, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseByte(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("55", true, 55)]
        [InlineData("68abhced", true, 68)]
        [InlineData("0", true, 0)] // min value
        [InlineData("255", true, 255)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToByte(string text, bool expectSuccess, byte expectedValue)
        {
            byte parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseByte(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("55", true, 55, 2)]
        [InlineData("68abhced", true, 68, 2)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("255", true, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToByteConsumed(string text, bool expectSuccess, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseByte(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region ushort

		[Theory]
        [InlineData("5535", true, 5535)]
        [InlineData("6836abhced", true, 6836)]
        [InlineData("0", true, 0)] // min value
        [InlineData("65535", true, 65535)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUshort(string text, bool expectSuccess, ushort expectedValue)
        {
            ushort parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseUInt16(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("5535", true, 5535, 4)]
        [InlineData("6836abhced", true, 6836, 4)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("65535", true, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUshortConsumed(string text, bool expectSuccess, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseUInt16(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("5535", true, 5535)]
        [InlineData("6836abhced", true, 6836)]
        [InlineData("0", true, 0)] // min value
        [InlineData("65535", true, 65535)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUshort(string text, bool expectSuccess, ushort expectedValue)
        {
            ushort parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseUInt16(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("5535", true, 5535, 4)]
        [InlineData("6836abhced", true, 6836, 4)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("65535", true, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUshortConsumed(string text, bool expectSuccess, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseUInt16(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		[Theory]
        [InlineData("5535", true, 5535)]
        [InlineData("6836abhced", true, 6836)]
        [InlineData("0", true, 0)] // min value
        [InlineData("65535", true, 65535)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUshort(string text, bool expectSuccess, ushort expectedValue)
        {
            ushort parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseUInt16(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("5535", true, 5535, 4)]
        [InlineData("6836abhced", true, 6836, 4)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("65535", true, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUshortConsumed(string text, bool expectSuccess, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseUInt16(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("5535", true, 5535)]
        [InlineData("6836abhced", true, 6836)]
        [InlineData("0", true, 0)] // min value
        [InlineData("65535", true, 65535)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUshort(string text, bool expectSuccess, ushort expectedValue)
        {
            ushort parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseUInt16(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("5535", true, 5535, 4)]
        [InlineData("6836abhced", true, 6836, 4)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("65535", true, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUshortConsumed(string text, bool expectSuccess, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseUInt16(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region uint

		[Theory]
        [InlineData("294967295", true, 294967295)]
        [InlineData("354864498abhced", true, 354864498)]
        [InlineData("0", true, 0)] // min value
        [InlineData("4294967295", true, 4294967295)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUint(string text, bool expectSuccess, uint expectedValue)
        {
            uint parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseUInt32(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("294967295", true, 294967295, 9)]
        [InlineData("354864498abhced", true, 354864498, 9)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("4294967295", true, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUintConsumed(string text, bool expectSuccess, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseUInt32(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("294967295", true, 294967295)]
        [InlineData("354864498abhced", true, 354864498)]
        [InlineData("0", true, 0)] // min value
        [InlineData("4294967295", true, 4294967295)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUint(string text, bool expectSuccess, uint expectedValue)
        {
            uint parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseUInt32(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("294967295", true, 294967295, 9)]
        [InlineData("354864498abhced", true, 354864498, 9)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("4294967295", true, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUintConsumed(string text, bool expectSuccess, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseUInt32(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		[Theory]
        [InlineData("294967295", true, 294967295)]
        [InlineData("354864498abhced", true, 354864498)]
        [InlineData("0", true, 0)] // min value
        [InlineData("4294967295", true, 4294967295)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUint(string text, bool expectSuccess, uint expectedValue)
        {
            uint parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseUInt32(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("294967295", true, 294967295, 9)]
        [InlineData("354864498abhced", true, 354864498, 9)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("4294967295", true, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUintConsumed(string text, bool expectSuccess, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseUInt32(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("294967295", true, 294967295)]
        [InlineData("354864498abhced", true, 354864498)]
        [InlineData("0", true, 0)] // min value
        [InlineData("4294967295", true, 4294967295)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUint(string text, bool expectSuccess, uint expectedValue)
        {
            uint parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseUInt32(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("294967295", true, 294967295, 9)]
        [InlineData("354864498abhced", true, 354864498, 9)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("4294967295", true, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUintConsumed(string text, bool expectSuccess, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseUInt32(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region ulong

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215)]
        [InlineData("0", true, 0)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUlong(string text, bool expectSuccess, ulong expectedValue)
        {
            ulong parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseUInt64(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615, 19)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUlongConsumed(string text, bool expectSuccess, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseUInt64(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215)]
        [InlineData("0", true, 0)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUlong(string text, bool expectSuccess, ulong expectedValue)
        {
            ulong parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseUInt64(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615, 19)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUlongConsumed(string text, bool expectSuccess, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseUInt64(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215)]
        [InlineData("0", true, 0)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUlong(string text, bool expectSuccess, ulong expectedValue)
        {
            ulong parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseUInt64(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615, 19)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUlongConsumed(string text, bool expectSuccess, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseUInt64(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215)]
        [InlineData("0", true, 0)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615)] // max value
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUlong(string text, bool expectSuccess, ulong expectedValue)
        {
            ulong parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseUInt64(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("8446744073709551615", true, 8446744073709551615, 19)]
        [InlineData("6745766045317562215abhced", true, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUlongConsumed(string text, bool expectSuccess, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseUInt64(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region sbyte

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53)]
        [InlineData("127", true, 127)] // max
        [InlineData("-128", true, -128)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0,)] // positive overflow test
        [InlineData("-129", false, 0,)] // negative overflow test
        public void ParseUtf8SpanToSbyte(string text, bool expectSuccess, sbyte expectedValue)
        {
            sbyte parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseSByte(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53, 2)]
        [InlineData("127", true, 127, 3)] // max
        [InlineData("-128", true, -128, 4)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToSbyteConsumed(string text, bool expectSuccess, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseSByte(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53)]
        [InlineData("127", true, 127)] // max
        [InlineData("-128", true, -128)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0)] // positive overflow test
        [InlineData("-129", false, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToSbyte(string text, bool expectSuccess, sbyte expectedValue)
        {
            sbyte parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseSByte(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53, 2)]
        [InlineData("127", true, 127, 3)] // max
        [InlineData("-128", true, -128, 4)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToSbyteConsumed(string text, bool expectSuccess, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseSByte(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53)]
        [InlineData("127", true, 127)] // max
        [InlineData("-128", true, -128)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0,)] // positive overflow test
        [InlineData("-129", false, 0,)] // negative overflow test
        public void ParseUtf16SpanToSbyte(string text, bool expectSuccess, sbyte expectedValue)
        {
            sbyte parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseSByte(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53, 2)]
        [InlineData("127", true, 127, 3)] // max
        [InlineData("-128", true, -128, 4)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToSbyteConsumed(string text, bool expectSuccess, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseSByte(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53)]
        [InlineData("127", true, 127)] // max
        [InlineData("-128", true, -128)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0)] // positive overflow test
        [InlineData("-129", false, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToSbyte(string text, bool expectSuccess, sbyte expectedValue)
        {
            sbyte parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseSByte(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("53abcdefg", true, 53, 2)]
        [InlineData("127", true, 127, 3)] // max
        [InlineData("-128", true, -128, 4)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToSbyteConsumed(string text, bool expectSuccess, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseSByte(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		#endregion

		#region short

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333)]
        [InlineData("32767", true, 32767)] // max
        [InlineData("-32768", true, -32768)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0,)] // positive overflow test
        [InlineData("-32769", false, 0,)] // negative overflow test
        public void ParseUtf8SpanToShort(string text, bool expectSuccess, short expectedValue)
        {
            short parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseInt16(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333, 4)]
        [InlineData("32767", true, 32767, 5)] // max
        [InlineData("-32768", true, -32768, 6)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToShortConsumed(string text, bool expectSuccess, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseInt16(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333)]
        [InlineData("32767", true, 32767)] // max
        [InlineData("-32768", true, -32768)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0)] // positive overflow test
        [InlineData("-32769", false, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToShort(string text, bool expectSuccess, short expectedValue)
        {
            short parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseInt16(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333, 4)]
        [InlineData("32767", true, 32767, 5)] // max
        [InlineData("-32768", true, -32768, 6)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToShortConsumed(string text, bool expectSuccess, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseInt16(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333)]
        [InlineData("32767", true, 32767)] // max
        [InlineData("-32768", true, -32768)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0,)] // positive overflow test
        [InlineData("-32769", false, 0,)] // negative overflow test
        public void ParseUtf16SpanToShort(string text, bool expectSuccess, short expectedValue)
        {
            short parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseInt16(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333, 4)]
        [InlineData("32767", true, 32767, 5)] // max
        [InlineData("-32768", true, -32768, 6)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToShortConsumed(string text, bool expectSuccess, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseInt16(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333)]
        [InlineData("32767", true, 32767)] // max
        [InlineData("-32768", true, -32768)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0)] // positive overflow test
        [InlineData("-32769", false, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToShort(string text, bool expectSuccess, short expectedValue)
        {
            short parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseInt16(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("5333abcdefg", true, 5333, 4)]
        [InlineData("32767", true, 32767, 5)] // max
        [InlineData("-32768", true, -32768, 6)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToShortConsumed(string text, bool expectSuccess, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseInt16(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		#endregion

		#region int

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647)]
        [InlineData("2147483647", true, 2147483647)] // max
        [InlineData("-2147483648", true, -2147483648)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0,)] // positive overflow test
        [InlineData("-2147483649", false, 0,)] // negative overflow test
        public void ParseUtf8SpanToInt(string text, bool expectSuccess, int expectedValue)
        {
            int parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseInt32(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647, 9)]
        [InlineData("2147483647", true, 2147483647, 10)] // max
        [InlineData("-2147483648", true, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToIntConsumed(string text, bool expectSuccess, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseInt32(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647)]
        [InlineData("2147483647", true, 2147483647)] // max
        [InlineData("-2147483648", true, -2147483648)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToInt(string text, bool expectSuccess, int expectedValue)
        {
            int parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseInt32(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647, 9)]
        [InlineData("2147483647", true, 2147483647, 10)] // max
        [InlineData("-2147483648", true, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToIntConsumed(string text, bool expectSuccess, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseInt32(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647)]
        [InlineData("2147483647", true, 2147483647)] // max
        [InlineData("-2147483648", true, -2147483648)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0,)] // positive overflow test
        [InlineData("-2147483649", false, 0,)] // negative overflow test
        public void ParseUtf16SpanToInt(string text, bool expectSuccess, int expectedValue)
        {
            int parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseInt32(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647, 9)]
        [InlineData("2147483647", true, 2147483647, 10)] // max
        [InlineData("-2147483648", true, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToIntConsumed(string text, bool expectSuccess, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseInt32(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647)]
        [InlineData("2147483647", true, 2147483647)] // max
        [InlineData("-2147483648", true, -2147483648)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToInt(string text, bool expectSuccess, int expectedValue)
        {
            int parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseInt32(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("474753647abcdefg", true, 474753647, 9)]
        [InlineData("2147483647", true, 2147483647, 10)] // max
        [InlineData("-2147483648", true, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToIntConsumed(string text, bool expectSuccess, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseInt32(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		#endregion

		#region long

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426)]
        [InlineData("9223372036854775807", true, 9223372036854775807)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0,)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0,)] // negative overflow test
        public void ParseUtf8SpanToLong(string text, bool expectSuccess, long expectedValue)
        {
            long parsedValue;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseInt64(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426, 18)]
        [InlineData("9223372036854775807", true, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToLongConsumed(string text, bool expectSuccess, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, false);
            bool result = PrimitiveParser.InvariantUtf8.TryParseInt64(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426)]
        [InlineData("9223372036854775807", true, 9223372036854775807)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToLong(string text, bool expectSuccess, long expectedValue)
        {
            long parsedValue;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseInt64(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426, 18)]
        [InlineData("9223372036854775807", true, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToLongConsumed(string text, bool expectSuccess, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf8.TryParseInt64(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426)]
        [InlineData("9223372036854775807", true, 9223372036854775807)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808)] // min
        [InlineData("-A", false, 0,)] // invalid character after a sign
        [InlineData("I am 1", false, 0,)] // invalid character test
        [InlineData(" !", false, 0,)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0,)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0,)] // negative overflow test
        public void ParseUtf16SpanToLong(string text, bool expectSuccess, long expectedValue)
        {
            long parsedValue;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseInt64(span, out parsedValue);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426, 18)]
        [InlineData("9223372036854775807", true, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToLongConsumed(string text, bool expectSuccess, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
			var span = UtfEncode(text, true);
            bool result = PrimitiveParser.InvariantUtf16.TryParseInt64(span, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426)]
        [InlineData("9223372036854775807", true, 9223372036854775807)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808)] // min
        [InlineData("-A", false, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0)] // invalid character test
        [InlineData(" !", false, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToLong(string text, bool expectSuccess, long expectedValue)
        {
            long parsedValue;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseInt64(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
            }
        }

		[Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("555642036585755426abcdefg", true, 555642036585755426, 18)]
        [InlineData("9223372036854775807", true, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToLongConsumed(string text, bool expectSuccess, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = PrimitiveParser.InvariantUtf16.TryParseInt64(arrayPointer, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
		#endregion

	}
}